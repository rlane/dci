#!/usr/bin/env ruby
require 'rubygems'
require 'libxml'
require 'net/http'
require 'cgi'
require 'fileutils'
require 'dci'
require 'xapian'
include LibXML
R = XML::Reader

CFG_FILENAME = 'etc/config.yaml'
fail "#{CFG_FILENAME} missing" unless File.exists? CFG_FILENAME
CFG = YAML.load_file CFG_FILENAME

BASE_URL = "http://#{CFG['http_address']}:#{CFG['http_port']}"

def get_raw(url)
	r = Net::HTTP.get_response(URI.parse(url))
	if r.is_a? Net::HTTPSuccess
		r.body
	else
		raise r.message
	end
end

def get_filelists
	blacklist = (File.open(CFG['blacklist_filename']).readlines rescue []).map { |l| l.chomp }
	usernames = get_raw(BASE_URL + "/users").split

	usernames.each do |username|
		filename = CFG['filelists_dir'] + "/#{username.gsub '/', '_'}.filelist.xml"
		next if File.exists?(filename) && (File.mtime(filename) > (Time.now - CFG['filelist_expire']))
		next if blacklist.member? username
		next if username == ''
		next if username.index('~') == 0
		next if username.index('*') == 0
		puts "downloading filelist from #{username}"
		begin
			data = get_raw(BASE_URL + "/filelist?username=#{CGI.escape username}")
			fail 'empty file' if data.empty?
			File.open(filename, "w") { |f| f.puts data }
		rescue Exception => e
			puts "download failed: #{e.message}"
			blacklist << username
			sleep 2
		end
	end

	File.open(CFG['blacklist_filename'], "w") { |f| blacklist.each { |l| f.puts l } }
end

def process_filelists
	filelists = Dir.glob(CFG['filelists_dir'] + "/*").take(CFG['index_limit'])

	def process_file tth, username, path, size
		{
			:tth => tth,
			:location => [username, path * '/'],
			:size => size
		}
	end

	def process_filelist data, xml, username
		path = []
		while (ret = xml.read; (ret == 1) || (ret == true))
			name, node_type = xml.name, xml.node_type
			if node_type == R::TYPE_ELEMENT && name == 'File'
				path.push xml['Name']
				data << process_file(xml['TTH'], username, path, xml['Size'].to_i)
				path.pop
			elsif node_type == R::TYPE_ELEMENT && name == 'Directory'
				path.push xml['Name']
			elsif node_type == R::TYPE_END_ELEMENT && name == 'Directory'
				path.pop
			end
		end
	end

	data = []
	i = 0
	n = filelists.length
	filelists.each do |filelist|
		i += 1
		fail 'bad filename' unless filelist =~ /^#{CFG['filelists_dir']}\/(.*).filelist.xml/
		username = $1
		begin
			File.open(filelist, "r") do |f|
				puts "(#{i}/#{n}) processing #{filelist}"
				xml = XML::Reader.io f
				next if xml.nil?
				process_filelist data, xml, username
			end
		rescue => e
			puts "exception: #{e.message}"
			#FileUtils.rm filelist
		end
	end

	data
end

def analyze raw_data
	i = 0
	n = raw_data.size
	raw_data.map do |v|
		i += 1
		puts "analyzed #{i}/#{n}" if (i % 10000) == 0
		run_heuristics v
	end
end

def index_doc db, tth, location, texts, terms, size, mimetype
	doc = Xapian::Document.new
	doc.add_term DCI::Index.mkterm(:tth, tth)
	terms.each { |type,term| doc.add_term DCI::Index.mkterm(type,term) }
	doc.add_term DCI::Index.mkterm(:username, location.first)
	term_generator = Xapian::TermGenerator.new()
	term_generator.stemmer = Xapian::Stem.new("english")
	term_generator.document = doc
	texts.each { |text| term_generator.index_text text, 1, DCI::Index::PREFIXES[:text] }
	doc.add_value DCI::Index::SIZE_VALUENO, size.to_s
	#puts doc.terms.map { |t| t.term }.join(' ')
	doc.data = Marshal.dump({:tth => tth, :location => location, :size => size, :mimetype => mimetype})
	db.add_document doc
end

def index data
	db = Xapian::WritableDatabase.new(CFG['index_filename'], Xapian::DB_CREATE_OR_OVERWRITE)
	n = data.size
	i = 0
	data.each do |v|
		#puts "indexing #{tth}"
		i += 1
		index_doc db, v[:tth], v[:location], v[:texts], v[:terms], v[:size], v[:mimetype]
		puts "indexed #{i}/#{n}" if (i % 10000) == 0
	end
end

get_filelists

raw_data = process_filelists
data = analyze raw_data
index data
